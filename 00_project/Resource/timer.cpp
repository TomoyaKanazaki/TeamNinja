//============================================================
//
//	タイマー処理 [timer.cpp]
//	Author：藤田勇一
//
//============================================================
//************************************************************
//	インクルードファイル
//************************************************************
#include "timer.h"
#include "manager.h"

//************************************************************
//	子クラス [CTimer] のメンバ関数
//************************************************************
//============================================================
//	コンストラクタ
//============================================================
CTimer::CTimer() : CObject(CObject::LABEL_UI),
	m_state		(STATE_NONE),	// 計測状態
	m_fTime		(0.0f),			// 計測時間
	m_fLimit	(0.0f),			// 制限時間
	m_bStop		(false)			// 計測停止状況
{

}

//============================================================
//	デストラクタ
//============================================================
CTimer::~CTimer()
{

}

//============================================================
//	初期化処理
//============================================================
HRESULT CTimer::Init(void)
{
	// メンバ変数を初期化
	m_state		= STATE_NONE;	// 計測状態
	m_fTime		= 0.0f;			// 計測時間
	m_fLimit	= 0.0f;			// 制限時間
	m_bStop		= false;		// 計測停止状況

	// 成功を返す
	return S_OK;
}

//============================================================
//	終了処理
//============================================================
void CTimer::Uninit(void)
{
	// オブジェクトを破棄
	Release();
}

//============================================================
//	更新処理
//============================================================
void CTimer::Update(const float fDeltaTime)
{
	switch (m_state)
	{ // 計測状態ごとの処理
	case STATE_NONE:
		break;

	case STATE_MEASURE:

		// 停止中の場合抜ける
		if (m_bStop) { break; }

		if (m_fLimit <= 0)
		{ // 制限時間が自然数ではない場合

			// デルタタイムを加算
			m_fTime += fDeltaTime;
		}

#if 0
		else
		{ // 制限時間が 0より大きい場合

			// 変数を宣言
			long nTime = m_nLimit - (timeGetTime() - m_dwTempTime);	// 現在タイム

			if (nTime > 0)
			{ // タイムが 0より大きい場合

				// 現在の計測ミリ秒を設定
				m_dwTime = nTime;
			}
			else
			{  // タイムが 0以下の場合

				// 現在の計測ミリ秒を設定
				m_dwTime = 0;

				// 計測を終了する
				End();
			}
		}
		else
		{ // 計測停止中の場合

			// 現在の停止ミリ秒を設定
			m_dwStopTime = timeGetTime() - m_dwStopStartTime;
		}
#endif

		break;

	case STATE_END:
		break;

	default:	// 例外処理
		assert(false);
		break;
	}

	// TODO
	DWORD dwTime = (DWORD)(m_fTime * 1000.0f);
	DWORD dwMin  = dwTime / 60000;
	DWORD dwSec  = (dwTime / 1000) % 60;
	DWORD dwMSec = dwTime % 1000;
	DebugProc::Print(DebugProc::POINT_LEFT, "計測時間：%d:%d:%d", dwMin, dwSec, dwMSec);

}

//============================================================
//	描画処理
//============================================================
void CTimer::Draw(CShader * /*pShader*/)
{

}

//============================================================
//	生成処理
//============================================================
CTimer *CTimer::Create
(

)
{
	// タイマーの生成
	CTimer *pTimer = new CTimer;
	if (pTimer == nullptr)
	{ // 生成に失敗した場合

		return nullptr;
	}
	else
	{ // 生成に成功した場合

		// タイマーの初期化
		if (FAILED(pTimer->Init()))
		{ // 初期化に失敗した場合

			// タイマーの破棄
			SAFE_DELETE(pTimer);
			return nullptr;
		}

		// 確保したアドレスを返す
		return pTimer;
	}
}

//============================================================
//	計測開始処理
//============================================================
void CTimer::Start(void)
{
	if (m_state != STATE_MEASURE)
	{ // タイムの計測中ではない場合

		// 非停止状態にする
		EnableStop(false);

		// 計測開始状態にする
		m_state = STATE_MEASURE;
	}
}

//============================================================
//	計測終了処理
//============================================================
void CTimer::End(void)
{
	if (m_state == STATE_MEASURE)
	{ // タイムの計測中の場合

		// 停止状態にする
		EnableStop(true);

		// 計測終了状態にする
		m_state = STATE_END;
	}
}

//============================================================
//	計測停止の有効無効の設定処理
//============================================================
void CTimer::EnableStop(const bool bStop)
{
	// 引数の停止状況を代入
	m_bStop = bStop;

	if (bStop)
	{ // 停止する場合


	}
	else
	{ // 再開する場合


	}
}

//============================================================
//	制限時間の設定処理
//============================================================
void CTimer::SetLimit(const ETime stateTime, float fTime)
{
	switch (stateTime)
	{ // タイムごとの処理
	case TIME_MSEC:	// ミリ秒

		// 制限時間を設定
		m_fLimit = fTime;
		break;

	case TIME_SEC:	// 秒

		// 引数をミリ秒に変換し制限時間を設定
		fTime *= 1000.0f;
		m_fLimit = fTime;
		break;

	case TIME_MIN:	// 分

		// 引数をミリ秒に変換し制限時間を設定
		fTime *= 60000.0f;
		m_fLimit = fTime;
		break;

	default:
		assert(false);
		break;
	}
}
